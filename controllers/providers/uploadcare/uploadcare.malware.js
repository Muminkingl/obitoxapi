/**
 * Uploadcare Malware Scanning Module
 * ClamAV integration with enterprise multi-layer caching
 * 
 * Operations:
 * 1. scanUploadcareFileForMalware - Initiate ClamAV scan
 * 2. checkUploadcareMalwareScanStatus - Poll scan status (CACHED)
 * 3. getUploadcareMalwareScanResults - Get detailed results (CACHED)
 * 4. removeUploadcareInfectedFile - Delete infected files
 */

import {
    UPLOADCARE_API_BASE,
    UPLOADCARE_CDN_BASE,
    extractUuidFromUrl,
    validateUploadcareCredentials,
    getUploadcareHeaders
} from './uploadcare.config.js';
import { updateUploadcareMetrics } from './uploadcare.helpers.js';

// Import multi-layer cache
import { checkMemoryRateLimit } from './cache/memory-guard.js';
import { checkRedisRateLimit } from './cache/redis-cache.js';
import redis from '../../../config/redis.js';
import { supabaseAdmin } from '../../../config/supabase.js';

/**
 * Scan file for malware using Uploadcare's ClamAV integration
 */
export const scanUploadcareFileForMalware = async (req, res) => {
    const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const startTime = Date.now();
    let apiKeyId;

    try {
        const { fileUrl, uuid, uploadcarePublicKey, uploadcareSecretKey } = req.body;
        apiKeyId = req.apiKeyId;
        const userId = req.userId || apiKeyId;

        if (!apiKeyId) {
            return res.status(401).json({
                success: false,
                error: 'UNAUTHORIZED',
                message: 'API key is required'
            });
        }

        // Validate Uploadcare credentials
        const credValidation = validateUploadcareCredentials(uploadcarePublicKey, uploadcareSecretKey);
        if (!credValidation.valid) {
            return res.status(400).json({
                success: false,
                error: credValidation.error,
                message: credValidation.message
            });
        }

        // LAYER 1: Memory guard
        const memoryStart = Date.now();
        const memCheck = checkMemoryRateLimit(userId, 'malware-scan');
        const memoryTime = Date.now() - memoryStart;

        if (!memCheck.allowed) {
            console.log(`[${requestId}] âŒ Blocked by memory guard in ${memoryTime}ms`);
            return res.status(429).json({
                success: false,
                error: 'RATE_LIMIT_EXCEEDED',
                message: 'Malware scan rate limit exceeded',
                layer: 'memory'
            });
        }

        // LAYER 2: Redis rate limit
        const redisStart = Date.now();
        const redisLimit = await checkRedisRateLimit(userId, 'malware-scan');
        const redisTime = Date.now() - redisStart;

        if (!redisLimit.allowed) {
            console.log(`[${requestId}] âŒ Blocked by Redis in ${redisTime}ms`);
            return res.status(429).json({
                success: false,
                error: 'RATE_LIMIT_EXCEEDED',
                message: 'Malware scan rate limit exceeded',
                layer: redisLimit.layer
            });
        }

        if (!fileUrl && !uuid) {
            return res.status(400).json({
                success: false,
                error: 'MISSING_PARAMETERS',
                message: 'Either fileUrl or uuid is required'
            });
        }

        let fileUuid = uuid;

        // Extract UUID from URL if not provided
        if (!fileUuid && fileUrl) {
            fileUuid = extractUuidFromUrl(fileUrl);
            if (!fileUuid) {
                return res.status(400).json({
                    success: false,
                    error: 'INVALID_URL',
                    message: 'Could not extract UUID from URL'
                });
            }
        }

        if (!fileUuid) {
            return res.status(400).json({
                success: false,
                error: 'INVALID_UUID',
                message: 'Could not determine file UUID'
            });
        }

        // Check if scan already initiated (Redis cache)
        const cacheKey = `uc_scan:${fileUuid}:initiated`;
        const cachedScanId = await redis.get(cacheKey);

        if (cachedScanId) {
            console.log(`[${requestId}] ðŸŽ¯ Scan already initiated (cached)`);
            return res.status(200).json({
                success: true,
                message: 'Malware scan already in progress',
                data: {
                    requestId: cachedScanId,
                    uuid: fileUuid,
                    status: 'scanning',
                    provider: 'uploadcare',
                    scanType: 'clamav',
                    cached: true
                }
            });
        }

        const operationStart = Date.now();

        // Execute virus scan using Uploadcare's ClamAV addon
        const scanResponse = await fetch('https://api.uploadcare.com/addons/uc_clamav_virus_scan/execute/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/vnd.uploadcare-v0.7+json',
                'Authorization': `Uploadcare.Simple ${uploadcarePublicKey}:${uploadcareSecretKey}`
            },
            body: JSON.stringify({
                target: fileUuid
            })
        });

        if (!scanResponse.ok) {
            const errorText = await scanResponse.text();
            updateUploadcareMetrics(apiKeyId, userId, 'uploadcare', 'failed', 0).catch(() => { });

            return res.status(scanResponse.status).json({
                success: false,
                error: 'SCAN_INITIATION_FAILED',
                message: 'Failed to initiate malware scan',
                details: errorText
            });
        }

        const scanResult = await scanResponse.json();
        const scanRequestId = scanResult.request_id;

        const operationTime = Date.now() - operationStart;
        const totalTime = Date.now() - startTime;

        // Cache scan initiation (5-min TTL)
        await redis.setex(cacheKey, 300, scanRequestId);

        console.log(`[${requestId}] âœ… Scan initiated in ${totalTime}ms`);

        // Background metrics update
        updateUploadcareMetrics(apiKeyId, userId, 'uploadcare', 'success', 0).catch(() => { });

        res.status(200).json({
            success: true,
            message: 'Malware scan initiated successfully',
            data: {
                requestId: scanRequestId,
                uuid: fileUuid,
                status: 'scanning',
                provider: 'uploadcare',
                scanType: 'clamav'
            },
            performance: {
                requestId,
                totalTime: `${totalTime}ms`,
                breakdown: {
                    memoryGuard: `${memoryTime}ms`,
                    redisCheck: `${redisTime}ms`,
                    scanInitiation: `${operationTime}ms`
                }
            }
        });

    } catch (error) {
        const totalTime = Date.now() - startTime;
        console.error(`[${requestId}] ðŸ’¥ Error after ${totalTime}ms:`, error);

        if (apiKeyId) {
            updateUploadcareMetrics(apiKeyId, req.userId, 'uploadcare', 'failed', 0).catch(() => { });
        }

        res.status(500).json({
            success: false,
            error: 'SERVER_ERROR',
            message: 'Internal server error during malware scan',
            details: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
        });
    }
};

/**
 * Check malware scan status (HEAVILY CACHED - 10 min TTL)
 */
export const checkUploadcareMalwareScanStatus = async (req, res) => {
    const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const startTime = Date.now();
    let apiKeyId;

    try {
        const { requestId: scanRequestId, uploadcarePublicKey, uploadcareSecretKey } = req.body;
        apiKeyId = req.apiKeyId;
        const userId = req.userId || apiKeyId;

        if (!apiKeyId) {
            return res.status(401).json({
                success: false,
                error: 'UNAUTHORIZED',
                message: 'API key is required'
            });
        }

        // Validate Uploadcare credentials
        const credValidation = validateUploadcareCredentials(uploadcarePublicKey, uploadcareSecretKey);
        if (!credValidation.valid) {
            return res.status(400).json({
                success: false,
                error: credValidation.error,
                message: credValidation.message
            });
        }

        // LAYER 1: Memory guard
        const memoryStart = Date.now();
        const memCheck = checkMemoryRateLimit(userId, 'malware-status');
        const memoryTime = Date.now() - memoryStart;

        if (!memCheck.allowed) {
            console.log(`[${requestId}] âŒ Blocked by memory guard in ${memoryTime}ms`);
            return res.status(429).json({
                success: false,
                error: 'RATE_LIMIT_EXCEEDED',
                message: 'Rate limit exceeded',
                layer: 'memory'
            });
        }

        // LAYER 2: Redis rate limit
        const redisStart = Date.now();
        const redisLimit = await checkRedisRateLimit(userId, 'malware-status');
        const redisTime = Date.now() - redisStart;

        if (!redisLimit.allowed) {
            console.log(`[${requestId}] âŒ Blocked by Redis in ${redisTime}ms`);
            return res.status(429).json({
                success: false,
                error: 'RATE_LIMIT_EXCEEDED',
                message: 'Rate limit exceeded',
                layer: redisLimit.layer
            });
        }

        if (!scanRequestId) {
            return res.status(400).json({
                success: false,
                error: 'MISSING_REQUEST_ID',
                message: 'Scan request ID is required'
            });
        }

        // LAYER 3: Check Redis cache for status (10-min TTL for completed scans)
        const cacheKey = `uc_scan:${scanRequestId}:status`;
        const cachedStatus = await redis.get(cacheKey);

        if (cachedStatus) {
            const statusData = JSON.parse(cachedStatus);
            const totalTime = Date.now() - startTime;

            console.log(`[${requestId}] ðŸŽ¯ Status from cache in ${totalTime}ms`);

            return res.status(200).json({
                success: true,
                message: 'Malware scan status retrieved from cache',
                data: {
                    ...statusData,
                    cached: true
                },
                performance: {
                    requestId,
                    totalTime: `${totalTime}ms`,
                    cached: true
                }
            });
        }

        const operationStart = Date.now();

        // Check scan status from Uploadcare
        const statusResponse = await fetch(`https://api.uploadcare.com/addons/uc_clamav_virus_scan/execute/status/?request_id=${scanRequestId}`, {
            method: 'GET',
            headers: getUploadcareHeaders(uploadcarePublicKey, uploadcareSecretKey)
        });

        if (!statusResponse.ok) {
            const errorText = await statusResponse.text();
            updateUploadcareMetrics(apiKeyId, userId, 'uploadcare', 'failed', 0).catch(() => { });

            return res.status(statusResponse.status).json({
                success: false,
                error: 'STATUS_CHECK_FAILED',
                message: 'Failed to check malware scan status',
                details: errorText
            });
        }

        const statusResult = await statusResponse.json();
        const status = statusResult.status;
        const isComplete = status === 'done';

        const operationTime = Date.now() - operationStart;
        const totalTime = Date.now() - startTime;

        const responseData = {
            requestId: scanRequestId,
            status: status,
            isComplete,
            provider: 'uploadcare',
            scanType: 'clamav'
        };

        // Cache completed scans for 10 minutes
        if (isComplete) {
            await redis.setex(cacheKey, 600, JSON.stringify(responseData));
        }

        console.log(`[${requestId}] âœ… Status check in ${totalTime}ms (${isComplete ? 'COMPLETE' : 'IN PROGRESS'})`);

        // Background metrics update
        updateUploadcareMetrics(apiKeyId, userId, 'uploadcare', 'success', 0).catch(() => { });

        res.status(200).json({
            success: true,
            message: 'Malware scan status retrieved successfully',
            data: responseData,
            performance: {
                requestId,
                totalTime: `${totalTime}ms`,
                breakdown: {
                    memoryGuard: `${memoryTime}ms`,
                    redisCheck: `${redisTime}ms`,
                    statusCheck: `${operationTime}ms`
                },
                cached: false
            }
        });

    } catch (error) {
        const totalTime = Date.now() - startTime;
        console.error(`[${requestId}] ðŸ’¥ Error after ${totalTime}ms:`, error);

        if (apiKeyId) {
            updateUploadcareMetrics(apiKeyId, req.userId, 'uploadcare', 'failed', 0).catch(() => { });
        }

        res.status(500).json({
            success: false,
            error: 'SERVER_ERROR',
            message: 'Internal server error during status check',
            details: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
        });
    }
};

/**
 * Get malware scan results (PERMANENTLY CACHED)
 */
export const getUploadcareMalwareScanResults = async (req, res) => {
    const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const startTime = Date.now();
    let apiKeyId;

    try {
        const { fileUrl, uuid, uploadcarePublicKey, uploadcareSecretKey } = req.body;
        apiKeyId = req.apiKeyId;
        const userId = req.userId || apiKeyId;

        if (!apiKeyId) {
            return res.status(401).json({
                success: false,
                error: 'UNAUTHORIZED',
                message: 'API key is required'
            });
        }

        // Validate Uploadcare credentials
        const credValidation = validateUploadcareCredentials(uploadcarePublicKey, uploadcareSecretKey);
        if (!credValidation.valid) {
            return res.status(400).json({
                success: false,
                error: credValidation.error,
                message: credValidation.message
            });
        }

        // LAYER 1: Memory guard
        const memoryStart = Date.now();
        const memCheck = checkMemoryRateLimit(userId, 'malware-results');
        const memoryTime = Date.now() - memoryStart;

        if (!memCheck.allowed) {
            console.log(`[${requestId}] âŒ Blocked by memory guard in ${memoryTime}ms`);
            return res.status(429).json({
                success: false,
                error: 'RATE_LIMIT_EXCEEDED',
                message: 'Rate limit exceeded',
                layer: 'memory'
            });
        }

        // LAYER 2: Redis rate limit
        const redisStart = Date.now();
        const redisLimit = await checkRedisRateLimit(userId, 'malware-results');
        const redisTime = Date.now() - redisStart;

        if (!redisLimit.allowed) {
            console.log(`[${requestId}] âŒ Blocked by Redis in ${redisTime}ms`);
            return res.status(429).json({
                success: false,
                error: 'RATE_LIMIT_EXCEEDED',
                message: 'Rate limit exceeded',
                layer: redisLimit.layer
            });
        }

        if (!fileUrl && !uuid) {
            return res.status(400).json({
                success: false,
                error: 'MISSING_PARAMETERS',
                message: 'Either fileUrl or uuid is required'
            });
        }

        let fileUuid = uuid;

        // Extract UUID from URL
        if (!fileUuid && fileUrl) {
            fileUuid = extractUuidFromUrl(fileUrl);
            if (!fileUuid) {
                return res.status(400).json({
                    success: false,
                    error: 'INVALID_URL',
                    message: 'Could not extract UUID from URL'
                });
            }
        }

        if (!fileUuid) {
            return res.status(400).json({
                success: false,
                error: 'INVALID_UUID',
                message: 'Could not determine file UUID'
            });
        }

        // LAYER 3: Check Redis cache for results (PERMANENT for scan results)
        const cacheKey = `uc_scan:${fileUuid}:results`;
        const cachedResults = await redis.get(cacheKey);

        if (cachedResults) {
            const resultsData = JSON.parse(cachedResults);
            const totalTime = Date.now() - startTime;

            console.log(`[${requestId}] ðŸŽ¯ Results from cache in ${totalTime}ms`);

            return res.status(200).json({
                success: true,
                message: 'Malware scan results retrieved from cache',
                data: {
                    ...resultsData,
                    cached: true
                },
                performance: {
                    requestId,
                    totalTime: `${totalTime}ms`,
                    cached: true
                }
            });
        }

        const operationStart = Date.now();

        // Get file info from Uploadcare (includes scan results)
        const fileInfoResponse = await fetch(`${UPLOADCARE_API_BASE}/files/${fileUuid}/`, {
            method: 'GET',
            headers: getUploadcareHeaders(uploadcarePublicKey, uploadcareSecretKey)
        });

        if (!fileInfoResponse.ok) {
            const errorText = await fileInfoResponse.text();
            updateUploadcareMetrics(apiKeyId, userId, 'uploadcare', 'failed', 0).catch(() => { });

            return res.status(fileInfoResponse.status).json({
                success: false,
                error: 'FILE_INFO_ERROR',
                message: 'Failed to get file information',
                details: errorText
            });
        }

        const fileInfo = await fileInfoResponse.json();

        // Extract scan results from appdata
        const scanResults = fileInfo.appdata?.uc_clamav_virus_scan || {};
        const isInfected = scanResults.infected === true;
        const virusName = scanResults.virus_name || null;

        const operationTime = Date.now() - operationStart;
        const totalTime = Date.now() - startTime;

        const responseData = {
            uuid: fileUuid,
            isInfected,
            virusName,
            scanComplete: !!scanResults.scanned_at,
            scannedAt: scanResults.scanned_at || null,
            provider: 'uploadcare',
            scanType: 'clamav',
            fileInfo: {
                filename: fileInfo.original_filename,
                size: fileInfo.size,
                mimeType: fileInfo.mime_type
            }
        };

        // Cache results permanently (scan results don't change)
        await redis.set(cacheKey, JSON.stringify(responseData));

        console.log(`[${requestId}] âœ… Scan results in ${totalTime}ms (Infected: ${isInfected})`);

        // Background metrics update
        updateUploadcareMetrics(apiKeyId, userId, 'uploadcare', 'success', 0).catch(() => { });

        res.status(200).json({
            success: true,
            message: 'Malware scan results retrieved successfully',
            data: responseData,
            performance: {
                requestId,
                totalTime: `${totalTime}ms`,
                breakdown: {
                    memoryGuard: `${memoryTime}ms`,
                    redisCheck: `${redisTime}ms`,
                    resultsCheck: `${operationTime}ms`
                },
                cached: false
            }
        });

    } catch (error) {
        const totalTime = Date.now() - startTime;
        console.error(`[${requestId}] ðŸ’¥ Error after ${totalTime}ms:`, error);

        if (apiKeyId) {
            updateUploadcareMetrics(apiKeyId, req.userId, 'uploadcare', 'failed', 0).catch(() => { });
        }

        res.status(500).json({
            success: false,
            error: 'SERVER_ERROR',
            message: 'Internal server error during results fetch',
            details: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
        });
    }
};

/**
 * Remove infected file (with cache invalidation)
 */
export const removeUploadcareInfectedFile = async (req, res) => {
    const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const startTime = Date.now();
    let apiKeyId;

    try {
        const { fileUrl, uuid, uploadcarePublicKey, uploadcareSecretKey } = req.body;
        apiKeyId = req.apiKeyId;
        const userId = req.userId || apiKeyId;

        if (!apiKeyId) {
            return res.status(401).json({
                success: false,
                error: 'UNAUTHORIZED',
                message: 'API key is required'
            });
        }

        // Validate Uploadcare credentials
        const credValidation = validateUploadcareCredentials(uploadcarePublicKey, uploadcareSecretKey);
        if (!credValidation.valid) {
            return res.status(400).json({
                success: false,
                error: credValidation.error,
                message: credValidation.message
            });
        }

        // LAYER 1: Memory guard
        const memoryStart = Date.now();
        const memCheck = checkMemoryRateLimit(userId, 'delete-infected');
        const memoryTime = Date.now() - memoryStart;

        if (!memCheck.allowed) {
            console.log(`[${requestId}] âŒ Blocked by memory guard in ${memoryTime}ms`);
            return res.status(429).json({
                success: false,
                error: 'RATE_LIMIT_EXCEEDED',
                message: 'Rate limit exceeded',
                layer: 'memory'
            });
        }

        // LAYER 2: Redis rate limit
        const redisStart = Date.now();
        const redisLimit = await checkRedisRateLimit(userId, 'delete-infected');
        const redisTime = Date.now() - redisStart;

        if (!redisLimit.allowed) {
            console.log(`[${requestId}] âŒ Blocked by Redis in ${redisTime}ms`);
            return res.status(429).json({
                success: false,
                error: 'RATE_LIMIT_EXCEEDED',
                message: 'Rate limit exceeded',
                layer: redisLimit.layer
            });
        }

        if (!fileUrl && !uuid) {
            return res.status(400).json({
                success: false,
                error: 'MISSING_PARAMETERS',
                message: 'Either fileUrl or uuid is required'
            });
        }

        let fileUuid = uuid;

        // Extract UUID from URL
        if (!fileUuid && fileUrl) {
            fileUuid = extractUuidFromUrl(fileUrl);
            if (!fileUuid) {
                return res.status(400).json({
                    success: false,
                    error: 'INVALID_URL',
                    message: 'Could not extract UUID from URL'
                });
            }
        }

        if (!fileUuid) {
            return res.status(400).json({
                success: false,
                error: 'INVALID_UUID',
                message: 'Could not determine file UUID'
            });
        }

        const operationStart = Date.now();

        // Delete from Uploadcare
        const deleteResponse = await fetch(`${UPLOADCARE_API_BASE}/files/${fileUuid}/`, {
            method: 'DELETE',
            headers: getUploadcareHeaders(uploadcarePublicKey, uploadcareSecretKey)
        });

        if (!deleteResponse.ok) {
            const errorText = await deleteResponse.text();
            updateUploadcareMetrics(apiKeyId, userId, 'uploadcare', 'failed', 0).catch(() => { });

            return res.status(deleteResponse.status).json({
                success: false,
                error: 'DELETE_FAILED',
                message: 'Failed to delete infected file',
                details: errorText
            });
        }

        const operationTime = Date.now() - operationStart;
        const totalTime = Date.now() - startTime;

        // Invalidate all caches for this file
        await Promise.all([
            redis.del(`uc_scan:${fileUuid}:initiated`),
            redis.del(`uc_scan:${fileUuid}:results`),
            redis.del(`uc_file:${fileUuid}`)
        ]);

        console.log(`[${requestId}] âœ… Infected file deleted in ${totalTime}ms`);

        // Background updates
        updateUploadcareMetrics(apiKeyId, userId, 'uploadcare', 'success', 0).catch(() => { });

        // NOTE: upload_logs table has been deleted - metrics tracked via Redis now

        res.status(200).json({
            success: true,
            message: 'Infected file deleted successfully',
            data: {
                uuid: fileUuid,
                deletedAt: new Date().toISOString(),
                provider: 'uploadcare',
                reason: 'malware_detected'
            },
            performance: {
                requestId,
                totalTime: `${totalTime}ms`,
                breakdown: {
                    memoryGuard: `${memoryTime}ms`,
                    redisCheck: `${redisTime}ms`,
                    deleteOperation: `${operationTime}ms`
                }
            }
        });

    } catch (error) {
        const totalTime = Date.now() - startTime;
        console.error(`[${requestId}] ðŸ’¥ Error after ${totalTime}ms:`, error);

        if (apiKeyId) {
            updateUploadcareMetrics(apiKeyId, req.userId, 'uploadcare', 'failed', 0).catch(() => { });
        }

        res.status(500).json({
            success: false,
            error: 'SERVER_ERROR',
            message: 'Internal server error during infected file removal',
            details: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
        });
    }
};
